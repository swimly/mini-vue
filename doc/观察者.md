### 观察者effect

在上篇我们通过`reactive`方法创建并返回了一个`Proxy`对象，并分别处理了它的`get`和`set`操作，但是当数据改变了，我们希望更新视图，这时候我们虽然能劫持到数据的变化，但是没有做任何处理，我们需要对数据的`get`和`set`增加更新的逻辑，并提供一个`API`给业务用来处理响应式数据的变化。

vue3中提供了`effect`，当effect回调函数中引用的响应式数据变化时，会触发`effect`回调函数的执行，相当于`vue2`中的`watcher`。

下面我们看一个使用实例

``` javascript
const proxy = reactive({
  name: 'swimly'
})
effect(() => {
  document.body.innerHTML = proxy.name
})
setTimeout(() => {
  proxy.name = 'hello effect'
}, 1000)
```

基于`vue3`响应式API的特点，需要将effect变成一个响应式函数，`effet`的响应式就是当数据变化时，`fn`会自动执行。实现`effect`这个函数的一个目标就是将`effect`回调函数中所有引用的响应式数据的属性收集起来，并和`effect`的回调函数关联上，在数据变化时再执行`effect`的回调函数。

也就是上面实例中，`proxy`对象的`name`属性再`effect`的回调函数中，要想让`effect`成为响应式的，就需要将`name`和`effect`关联起来，当name的值变化了，就执行`effect`的回调函数。

如果要把`effect`变成响应式，需要定义一个创建响应式的方法，用于创建一个`effect`函数，这里我们用`es6`的`class`来实现，通过创建一个`ReactiveEffect`类，在创建该类的实例的时候会自动调用传入的`fn`，并且返回该`fn`，下面就通过代码来实现相关功能。

创建`src/reactivity/effect.ts`

``` javascript
let activeEffect;
class ReactiveEffect {
  private _fn: any
  constructor (fn) {
    this._fn = fn
  }
  public run () {
    activeEffect = this
    this._fn()
  }
}
export function effect (fn) {
  const _effect = new ReactiveEffect(fn)
  _effect.run()
}
```

首先，我们实现`effect`函数以及基础的`ReactiveEffect`功能，在`effect`函数体内，接收一个函数`fn`，最后返回一个`ReactiveEffect`实例，而在`ReactiveEffect`内部，将接收的`fn`保存在自身的`_fn`上，并定义好了一个`run`方法，在方法内，将当前实例对象赋值给`activeEffect`，并立即执行传入的`fn`函数。

?> 思考：不是说只用实现自动调用`effect`传入的函数吗？为什么还要定义`activeEffect`，并且将当前的`ReactiveEffect`赋值给它？

我们定义一个全局变量`activeEffect`，这样是为了把当前创建的`effect`实例存起来，在收集依赖的时候可以拿到这个值。

到此，我们就完成了`effect`最基础的功能，当执行`effect`的时候，传入的`fn`会默认执行一次，接下来我们再来思考一个问题。

怎样才能让属性和函数进行关联呢？下一节，我们一起来了解如何收集依赖。