## Effect

上一节，我们已经完成`reactive`的基本逻辑，这一节，我们来创建一个`effect`，为后面的依赖收集和触发依赖做准备。

### 单测

下面，就跟着单测一起来了解`effect`的功能点。

``` javascript
// src/reactivity/test/effect.spec.ts
import {effect} from "../effect"
import {reactive} from "../reactive"
describe("effect", () => {
  it("happy path", () => {
    const user = reactive({
      age: 10
    })
    let nextAge;
    effect(() => {
      nextAge = user.age + 1
    })
    expect(nextAge).toBe(11)
  })
})
```

同`reactive`一样，`effect`也是一个函数，默认接收一个`fn`作为参数，从单例可以看出当执行`effect(fn)`的时候，默认会执行里面的`fn`，这一节，我们就来完成这个简单的功能，至于怎么做到数据同步更改，等我们完成后面的两节`收集依赖`和`触发依赖`。

### 编码

在这里有一点跟`reactive`不同，effect模块我们不仅仅是导出一个`effect`函数，还需要一个公共的类`ReactiveEffect`，当然你也可以用构造函数来代替它的功能。

创建`src/reactivity/effect.ts`

``` javascript
let activeEffect;
class ReactiveEffect {
  private _fn: any
  constructor (fn) {
    this._fn = fn
  }
  public run () {
    activeEffect = this //将当前实例对象赋值给全局变量activeEffect，在依赖收集的时候有用
    this._fn()
  }
}
export function effect (fn) {
  const _effect = new ReactiveEffect(fn)
  _effect.run()
}
```

上面便是我们这一节要完成的所有代码及功能，看起来很简单，但是却有点不大好理解，为什么要这么写？可以把`effect`当成一个纽带，当然它更像`vue2`中的`watcher`。

### 总结

这节课，我们完成了`effect`的主要功能，通过`effect(fn)`返回一个用`ReactiveEffect`包裹的实例对象，当执行函数的时候会自动调用内部的`run`方法，实际上也就是通过`effect`传入的`fn`。

下一节，我们将一起来实现依赖收集。