## Reactive

何为响应式对象，在我看来就是一个可以进行拦截的对象，`vue2`采用的是`Object.defineProperty`，`vue3`采用的是`Proxy`，至于`vue3`为什么要采用`proxy`这里我们不做过多解释，大家可自行了解。

### 单测

下面，跟着下面的单测一起来了解下`reactive`的具体功能点。

``` javascript
// src/reactivity/test/reactive.spec.ts

import {reactive} from '../reactive'
describe("reactive", () => {
  it("happy path", () => {
    const origin = {
      foo: 1
    }
    const obj = reactive(origin)
    expect(obj).not.toBe(origin)
    expect(obj.foo).toBe(1)
  })
})
```

在vue3里，直接通过一个`reactive(obj)`函数创建一个`proxy`对象，返回的对象属性和值都和`obj`保持一直，但他们属于不同的两个对象。

### 代码实现

根据上面单测的功能点，我们开始一步步的来实现我们的`reactive`函数。

创建`./src/reactivity/reative.ts`文件

#### 1、导出一个`reactive`函数，接收用户传入的`object`数据。

``` javascript
export function reactive (raw) {
  // write at this
}
```
#### 2、返回一个`Proxy`实例

`Proxy`接收2个参数，第一个是需要劫持的`object`，第二个参数是一个`options`，这里我们只用设置`get`和`set`。

``` javascript
export function reactive (raw) {
  return new Proxy(raw, {
    get (target, key) {},
    set (target, key, value) {}
  })
}
```
#### 3、处理`get`请求

当获取这个响应式对象的某个属性时调用，`target`就是获取的`object`，`key`就是获取的对象属性名称。

例如：`obj.name`，target代表`obj`，而key则代表`name`。

提示：这里的`Reflect.get(target, key)`其实就是获取`target`对象的`key`属性的值，最后在`get`中返回这个值即可。

``` javascript
get (target, key) {
  const res = Reflect.get(target, key)
  return res
}
```

#### 4、处理`set`赋值

当执行了赋值操作时会调用`set`方法，`target`是操作的对象，`key`是操作对象的属性名称，`value`是赋值。

`Reflect.set(target, key, value)`即是给`target`对象的`key`属性赋值`value`，该执行结果是`boolean`，即代表赋值成功与否。

``` javascript
set (target, key, value) {
  const res = Reflect.set(target, key, value)
  return res
}
```

到这里，我们就成功创建了一个响应式对象，给这个响应式对象添加了`set`，和`get`操作。


### 总结

最后我们再一起来回顾一下这一节我们实现的代码及功能，在`reactive.ts`中我们导出了`reactive`函数，自身接收一个`obj`作为参数，并基于`obj`返回一个`proxy`对象，我们还简单的处理了一下`proxy`的`get`和`set`请求，后面我们将会对这个`proxy`对象进行完善，真正达到响应式。

下一节，我们将一起了解vue3的`effect`。