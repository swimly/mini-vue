### 响应式对象reactive

在正式进入`vue3`的响应式原理之前，我们先来回顾一下`vue2`的响应式存在什么缺陷，vue2使用的是`Object.defineProperty`的方式来对数据进行拦截。

?> 1、默认会对劫持的数据进行递归

?> 2、不支持数据，数组长度改变是无效的

?> 3、不能劫持不存在的属性


我们回顾一下vue3中创建响应式对象的方法，并非vue2那种通过`data`返回一个对象，而是通过调用`reactive`方法返回一个`proxy`对象，从而对数据进行拦截，和`vue2`的方式截然不同。

``` javascript
import {reactive} from 'vue'
export default {
  setup () {
    const state = reactive({
      name: 'swimly'
    })
  }
}
```

废话不多说，下面就开始编写`reactive`的代码。

创建`./src/reactivity/reative.ts`文件

1、导出一个`reactive`函数，接收用户传入的`object`数据。

``` javascript
export function reactive (raw) {
  // write at this
}
```
2、返回一个`Proxy`实例

`Proxy`接收2个参数，第一个是需要劫持的`object`，第二个参数是一个`options`，这里我们只用设置`get`和`set`。

``` javascript
export function reactive (raw) {
  return new Proxy(raw, {
    get (target, key) {},
    set (target, key, value) {}
  })
}
```
3、处理`get`返回

当程序获取这个响应式对象的某个属性时调用，`target`就是获取的`object`，`key`就是获取的对象属性名称。

例如：`obj.name`，target代表`obj`，而key则代表`name`。

提示：这里的`Reflect.get(target, key)`其实就是获取`target`对象的`key`属性的值，最后在`get`中返回这个值即可。

``` javascript
get (target, key) {
  const res = Reflect.get(target, key)
  return res
}
```

4、处理`set`赋值

当程序执行了赋值操作时会调用`set`方法，`target`是操作的对象，`key`是操作对象的属性名称，`value`是赋值。

`Reflect.set(target, key, value)`即是给`target`对象的`key`属性赋值`value`，该执行结果是`boolean`，即代表赋值成功与否。

``` javascript
set (target, key, value) {
  const res = Reflect.set(target, key, value)
  return res
}
```

到这里，我们就成功创建了一个响应式对象，给这个响应式对象添加了`set`，和`get`操作，而我们仅仅是赋值和返回值，并没有做其他任何处理。

下一节，我们将讲解effect观察者的实现。
