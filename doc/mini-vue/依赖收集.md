## 依赖收集&触发依赖

在此之前，我们已经实现了`reactive`和`effect`，并且留了一个全局变量`activeEffect`，我们一起来思考一下，这些东西有什么用，又是怎么联系在一起的。

### 分析

`reactive(obj)`返回的是一个`proxy`代理对象，当程序执行到`obj.xx`的时候会触发代理对象的`get`请求，当执行`obj.xx = xx`的时候则会触发代理对象的`set`请求

`effect(fn)`返回的是一个`ReactiveEffect`实例对象，在函数执行的时候给`activeEffect`赋值为当前的实例对象，而实例对象存储的有用户传入的`fn`，并且可通过内部的`run`方法来执行这个`fn`

### 思考

通过上面的准备工作，我们是否可以这样做？当我们在`effect`函数内部触发`obj`的get请求的时候，我们去把`effect(fn)`这个函数存起来，当程序触发它的`set`请求的时候，我们再从我们存储的变量中取出来，挨个去执行实例对象中的`run`函数，那不就相当于，当数据更新的时候，会自动去执行`effect(fn)`中的`fn`吗？

### 单测

下面我们再来完善`effect`的单测，加上更新机制

``` javascript
describe("effect", () => {
  it("happy path", () => {
    ...
    user.age++
    expect(nextAge).toBe(12)
  })
})
```

当我们的响应式对象其中的某个属性值改变的时候，我们希望`nextAge`也会同步改变。

### 编码

我们一步步来实现依赖收集和触发依赖的功能

``` javascript
// src/reactivity/reactive.ts
import {track, trigger} from './effect'
export function reactive (raw) {
  return new Proxy(raw, {
    get (target, key) {
      ...
      track(target, key)
      ...
    },
    set (target, key, value) {
      ...
      trigger(target, key)
      ...
    }
  })
}
```

上面的`track`函数便是我们用来收集依赖，`trigger`用来触发依赖，这两个函数我们都是写在`effect.ts`文件中。

#### 依赖收集

单纯的说依赖收集，但是到底依赖是什么，我们到底要收集什么，又该怎么存储，请大家仔细观摩下面的图。

<img src="doc/img/img1.jpeg" style="width: 70%;">

我们实际要存储的数据结构便是`target`->`key`->`effect`。


``` javascript
const targetMap = new Map()
export function track (target, key) {
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  let dep = depsMap.get(key)
  if (!dep) {
    dep = new Set()
    depsMap.set(key, dep)
  }
  dep.add(activeEffect)
}
```

在上述的实现代码中，我们通过一个全局变量`targetMap`来存储我们收集的所有依赖，数据格式是`Map`，然后依次从中读取`target.key`的存储容器`dep`，然后将`activeEffect`存进去，这样我们就将所有的`fn`存储起来。

#### 触发依赖

上面，我们已经收集好了所有的依赖，触发依赖就显得简单多了。

``` javascript
export function trigger (target, key) {
  const depsMap = targetMap.get(target)
  const dep = depsMap.get(key)
  dep.forEach((effect) => {
    effect.run()
  })
}
```

根据`trigger(target, key)`传入的值，我们从`targetMap`中取出对应的所有`effect`实例对象，然后执行所有实例的`run`方法，这样便是我们的触发依赖。

### 总结

其实`vue3`的响应式最根本的功能我们已经基本完成，也能达到数据跟随改变了，以前没了解的时候总觉得很神奇，现在看看其实也就这么回事，编码思路真的太重要，哪怕你懂所有的语法api可最后不一定能写出如此精妙的代码，好好学习吧，骚年们！

下一节，我们将来完善`effect`的`runner`功能。