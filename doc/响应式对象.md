## 响应式对象

说起对象，我们都很熟悉，平常用的也比较多，从`vue`诞生以来，有一个概念一直萦绕在我们耳边，那便是`响应式对象`，`数据双向绑定`，其实这一切都是对`对象`做了一层代理拦截，vue2使用的是`Object.definePropery`，而`vue3`使用的是`Proxy`，相比而言除了兼容性不佳，`Proxy`自然是最佳选择。

下面我们就基于`Proxy`创建一个`响应式`对象。

首先，我们回顾一下vue3中创建响应式对象的方法，并非vue2那种通过`data`返回一个对象，而是通过`reactive`方法创建。

``` javascript
import {reactive} from 'vue'
export default {
  setup () {
    const state = reactive({
      name: 'swimly'
    })
  }
}
```

下面就开始实现`reactive`。

创建`./src/reactivity/reative.ts`文件

1、导出一个`reactive`函数，接收用户传入的`object`数据。

``` javascript
export function reactive (raw) {
  // write at this
}
```
2、返回一个`Proxy`实例

`Proxy`接收2个参数，第一个是需要劫持的`object`，第二个参数是一个`options`，这里我们只用设置`get`和`set`。

``` javascript
export function reactive (raw) {
  return new Proxy(raw, {
    get (target, key) {},
    set (target, key, value) {}
  })
}
```
3、处理`get`返回

当程序获取这个响应式对象的某个属性时调用，`target`就是获取的`object`，`key`就是获取的对象属性名称。

例如：`obj.name`，target代表`obj`，而key则代表`name`。

提示：这里的`Reflect.get(target, key)`其实就是获取`target`对象的`key`属性的值，最后在`get`中返回这个值即可。

``` javascript
get (target, key) {
  const res = Reflect.get(target, key)
  return res
}
```

4、处理`set`赋值

当程序执行了赋值操作时会调用`set`方法，`target`是操作的对象，`key`是操作对象的属性名称，`value`是赋值。

`Reflect.set(target, key, value)`即是给`target`对象的`key`属性赋值`value`，该执行结果是`boolean`，即代表赋值成功与否。

``` javascript
set (target, key, value) {
  const res = Reflect.set(target, key, value)
  return res
}
```

到这里，我们就成功创建了一个响应式对象，给这个响应式对象添加了`set`，和`get`操作，而我们仅仅是赋值和返回值，并没有做其他任何处理。

最终我们的代码应该如下：

``` javascript
export function reactive (raw) {
  return new Proxy(raw, {
    get (target, key) {
      const res = Reflect.get(target, key)
      return res
    },
    set (target, key, value) {
      const res = Reflect.set(target, key, value)
      return res
    }
  })
}
```

下一节，我们将了解如何收集依赖。