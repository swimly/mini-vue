### trigger触发依赖

在上节，我们已经将`target`，`key`，`effect`（是一个`ReactiveEffect`实例对象，会自动调用传入的`fn`）的对应关系都存储起来了，下面，我们就要通过监听响应式对象的`set`方法，根据`target`和`key`从`targetMap`中取出所有的`effect`，依次调用内部的`run`方法即可。

同样，我们还是在`src/reactivity/effect.ts`文件内编写依赖触发的相关代码。

``` javascript
export function trigger (target, key) {
  let depsMap = targetMap.get(target)
  let dep = depsMap.get(key)
  dep.forEach((effect) => {
    effect.run()
  })
  // 推荐下面的写法，由于我们还没处理打包的兼容性，所以暂时用forEach代替。
  // for (const effect of dep) {
  //   effect.run()
  // }
}
```

上面就是触发依赖的所有过程，首先通过`target`获取该对象所有的`depsMap`，然后根据`key`获取该对象下某个属性的所有`effect`，最后执行所有`effect`的`run`方法即可。

最后，在`src/reactivity/reactive.ts`中调用`trigger`的依赖

``` javascript
import {
  ...
  trigger
} from './effect'

export function reactive (raw) {
  return new Proxy(raw, {
    ...,
    set (target, key, value) {
      ...
      trigger(target, key)
      ...
    }
  })
}
```

到此，我们就大致完成了响应式对象的完整流程了，为了测试我们写的功能是否符合我们的预期。

``` html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script type="module">
    import {reactive, effect} from '../../dist/index.esm.js'
    const obj = reactive({
      age: 10
    })
    let age
    effect(() => {
      age = obj.age + 1
    })
    obj.age = 11
    console.log(age)  //不出意外这里会打印 12
  </script>
</body>
</html>
```

最终，我们会获得`12`，在上述例子中，

1、我们创建了一个响应式对象`obj`，

2、随后创建一个全局变量`age`，

3、执行`effect`之后，便会将传入的`fn`包装成为一个`ReactiveEffect`，并且第一次执行在函数体内的代码，给`age`赋值为`obj.age + 1`，这时候会调用响应式对象`obj`的get方法，其中`target`是`{age: 1}`，`key`为：`age`，到这一步会触发`Proxy`内部的`get`方法，触发`track`，将当前的`ReactiveEffect`实例按照`target`->`key`->`effect`的对应关系存入全局变量`targetMap`中

4、当我们再次给`obj.age`赋值的时候便会触发`set`内部的`trigger`而触发`{age: 1}`对象上`age`的所有`effect`实例中的`run`方法，便会在执行`effect`内部函数的代码，经过`obj.age = 11`之后，再次执行`age = obj.age + 1`，便相当于`age = 11 + 1`，自然就会返回`12`。